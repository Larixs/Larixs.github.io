#JavaScript设计模式与开发实践

## 开放封闭原则

定义：

软件实体（类、模块、函数等）应该可以扩展，但是不可以修改。

开闭原则主要体现在两个方面：
 
1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。
2. 对修改封闭，意味着类一旦设计完成，就可以独立其工作，而不要对类尽任何修改。


## 第二部分 设计模式
### 第四章 单例模式
____
**单例模式的定义：**

保证一个类仅有一个实例，并提供一个访问它的全局访问点。
____

**应用：** 

线程池、全局缓存、window对象、登陆浮窗
____
**实现方式：**

1、 使用类的某个特定方法来创建单例对象（缺点：不透明）p60

2、使用IIFE和闭包来创建透明的单例类（缺点：代码复杂度稍高，如果该类的原型复用度低）p62

3、将单例类的原型提出来作为一个普通的原型，引入代理类来帮助该原型实现单例模式。（透明，代码整洁，原型复用度高）
____
**注意点：**

由于单例模式需要确保只有一个实例，并且提供全局访问，因此可能会带来命名污染。

可以使用以下几种方式降低污染：

1、 使用命名空间 p64
    A 对象字面量的方式
    B 动态创建命名空间 
    
2、 使用闭包封装私有变量 p65
____	
**惰性单例：**

在需要的时候才创建实例对象。

通用的惰性单例 p68
____
### 第五章 策略模式

____

**策略模式的定义：**

定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。

____

**应用：**

针对同一种问题，不同类型数据需要有不同解决方案。例如发奖金这个问题，不同绩效的人会有不同的年终奖计算方式。

____

**基本思路：**

一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，它接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。p73

即context负责获取参数和选择策略，而具体的运算过程都交给策略来做。

____
**实现：**

- 所有策略都是单个的function，context使用if-else挑选策略。（缺点：context庞大，需要包含所有逻辑分支，缺乏弹性，一旦策略有变化，例如策略名称，context和策略可能都要修改）

- 策略包在一个对象中，context使用属性名挑选策略。或者说，将要选择的策略直接传入context，由context直接调用。（消灭if-else语句，策略的实现方式与context完全解耦）

____
**应用：** 

表单验证

___
### 第六章 代理模式

____

**代理模式的定义：**

为一个对象提供一个代用品或占位符，以便控制对它的访问。
____

**保护代理与虚拟代理：**

保护代理：控制不同权限的对象对目标对象的访问。

虚拟代理：将一些开销很大的对象，延迟到真正需要它的时候才去创建。

____

**应用：** 

图片预加载（虚拟代理），合并http请求（虚拟代理），惰性加载（虚拟代理），缓存代理（p100）

**其余代理：**

防火墙代理、远程代理、保护代理、智能引用代理、写时复制代理


### 第七章 迭代器模式

____

将迭代的过程从业务逻辑中分离出来。现在绝大部分语言都内置了迭代器。

____

### 第八章 发布—订阅模式

也叫观察者模式。

其优点明显：1.时间上解耦 2.对象之间的解耦

缺点： 消耗一定的时间和内存，当过多使用时，模块与模块之间的联系隐藏到了背后，不易追踪bug

**“推模式”：**
事件发生时，发布者一次性把所有更新的状态和数据都推送给订阅者。

**“拉模式”：**
事件发生时，发布者仅仅通知事件已经发生，由订阅者调用发布者提供的接口来获取数据。

### 第九章 命令模式

**应用场景：**

有时候需要向某些对象发送请求，但是并不知道的请求的接收者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

请求者将事件转化为命令，接收者按照命令执行封装好的函数。

命令可以撤销、重做、排队。

**宏命令:**

一组命令的集合，是命令模式与组合模式的产物。

### 第十章 组合模式

宏命令就是命令模式和组合模式的产物，它生成了一颗命令树，非叶子节点把命令往下传递，直到找到树的叶子节点。叶子节点才是真正要执行的命令。

每当对宏命令进行一次请求时，实际上就是深度遍历了这棵命令树。

**一些值得注意的地方：（p147）**

1. 组合模式不是父子关系，是has-a（聚合）关系。
2. 对叶对象操作的一致性。
3. 双向映射关系：当一个叶子节点在树里重复出现时，并不适合使用组合模式。这种情况下必须建立双向映射关系。

**引用父对象**

在宏命令中，树的结构是从上至下的。但是有时候我们需要子节点保持对父节点的引用。

**应用场景：**

- 表示对象的部分-整体层次结构
- 客户希望统一对待树中的所有对象。

### 第十一章 模板方法（Template Method）

基于继承的设计模式

模板方法封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。

抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，需要子类重写这些方法。如果能确定所有子类都会使用某一个具体方法时，这个具体方法也可以写在抽象类中。

如果子类没有重写抽象方法的话，那么程序就会报错。检查子类有没有重写所有抽象方法的方案有以下两个：

1. 使用鸭子类型来模拟接口检查，确保子类重写了父类的办法。但是这个方案会带来不必要的复杂性，而且需要程序员主动检查这些接口。

2. 在需要被重写的抽象方法中直接抛出异常。如果抽象方法没有被重写，那么子类在调用该方法时就会沿着原型链找到抽象方法并运行，此时就可以获得一个报错。 实现简单，代价小，但是获得错误的时间点太靠后，只能将程序运行起来才知道是否报错。

**钩子方法**

放置钩子是隔离变化的一种常见手段。我们在父类容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要挂钩，这由子类自行决定。

**好莱坞原则**

我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些组件。而底层组件不可以去使用高层组件。

好莱坞原则有多个适用场景，例如模板方法，发布-订阅模式，回调函数等等。


### 第十二章 享元模式（flyweight）

用于性能优化。

**内部状态与外部状态：**

- 内部状态储存于对象内部
- 内部状态可以被一些对象共享
- 内部状态独立于具体的场景，通常不会改变
- 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。
- 内部状态有多少种组合，系统中便最多存在多少个对象。

使用享元模式的关键是如何区别内部状态和外部状态。
 
**享元模式的通用结构：**

- 对象工厂。只有当某种共享对象被真正需要时，它才从工厂中被创建出来。(有点单例模式的意思)
- 管理器。记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来。

**适用场景：**

- 一个程序中使用了大量的相似对象
- 由于使用了大量对象，造成了很大的内存开销
- 对象的大多数状态都可以变为外部状态
- 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象

**对象池** p175

对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后，再进入池子等待下次被获取。

对象池应用广泛，http连接池和数据库连接池都是其代表应用。在web前端，对象池使用最多的场景大概就是跟DOM有关的操作。如何避免频繁地创建和删除DOM节点就成了一个有意义的话题。

### 第十三章 职责链模式

**定义：**

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。

职责链模式就像是把每部分的处理函数当作节点做成一个单向链表，如果当前节点不能处理则向后传递。

我自己将书上p183的例子用数组储存链表，用Array.prototype.every实现顺序执行。这个无法实现异步职责链。

    var order500 = function(orderType, pay, stock){
      if( orderType === 1 && pay === true){
        console.log("500元，100优惠券")
      }else{
        return true
      }
    }
    var order200 = function(orderType, pay, stock){
      if( orderType === 2 && pay === true){
        console.log("200元，50优惠券")
      }else{
        return true
      }
    }
    var orderNormal = function(orderType, pay, stock){
      if( orderType === 3){
        if( stock > 0){
          console.log("普通购买，无优惠券");
        }else{
          console.log("手机库存不足")
        }
      }
    }
    
    function chain(arr){
      return (function(orderType, pay, stock){
        arr.every(function(i){
          return i(orderType, pay, stock)
        })
      })
    }
    var order = chain([order500, order200, orderNormal]);
    order(1, true, 500)
    
**注意点**

当职责链中没有任何一个节点可以处理时，请求就得不到回复。我们可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。

过长的职责链会带来性能损耗？（可是不用职责链也要用if-else分支，都得走一遍，有什么区别呢？）

**AOP实现职责链**

改写Function.prototype.after （3.2.3节）

缺点: 叠加了函数作用域，如果链条太长，那么对性能也会有较大影响。


### 第十四章 中介者模式

中介模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用。所以当一个对象发生改变时，只需要通知中介者对象即可。

中介者模式使各个对象之间得以解耦，以中介者和对象直接的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。

**缺点:**

系统会新增一个中介者对象，因为对象直接交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。

