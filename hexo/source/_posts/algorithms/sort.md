---
title: 排序
categories: 算法 algorithms
---

经典算法，排序。

## 基础术语

Θ渐近紧确界，O渐近上界。

# 比较排序

通过元素的比较进行的排序算法： 插入排序、选择排序、冒泡排序、归并排序、堆排、快排。

任何比较排序在最坏情况下都要经过Ω(nlgn)次比较。因此，归并排序和堆排是渐进最优的。

## 归并排序

思想：分治法，拆成更小的数组进行排序，排序后合并成大数组继续排序。

时间复杂度： O(nlgn)

## 堆排

思想：建立最小堆或者最大堆，每次取出根元素并继续维护堆的性质，构成排序。

时间复杂度: 平均O(nlgn) Θ

## 快排

思想： 分治法，选择最后一位为标兵，将大数组以大于标兵或者小于标兵划分为两个子数组，再对这两个子数组进行快排。

特点： 原址排序

时间复杂度：

只要划分是常数比例的，算法的运行时间总是O(nlgn)。

- 期望Θ(nlgn)。
- 最坏Θ(n<sup>2</sup>)
- 元素互异时，期望O(nlgn)。

### 快排的随机化

由于随机化能使快排的性能达到较好的期望性能，因此快排中采用一种**随机抽样(random sampling)**的技术。

随机抽样是将子数组的标兵随机化，即随机抽取一位作为标兵。

随机化虽然不能提高最坏情况的性能，但是可以提升平均情况的期望性能。

类似的方法还有三数取中（三位随机元素选中位数做哨兵）

# 线性排序

用运算而非比较来确定排序顺序：计数排序、基数排序、桶排序

## 计数排序

输入要求：输入n个元素都是0-k区间内的一个整数。

过程：先统计0-k中各元素出现的次数，然后根据次数计算出0-k中每个元素应该在的位置，最后通过原序列计算出的位置重新输出一个排序数组。

时间复杂度：

k = O(n)时，排序的运行时间为Θ(n)。

计数排序是**稳定**的。计数排序经常会被用作基数排序算法的一个子过程。


