---
title: JavaScript设计模式与开发实践
tags: [design patterns, ES]
categories: books
---

# JavaScript设计模式与开发实践

## 面向对象设计的原则

### 开放封闭原则

#### **定义：**

软件实体（类、模块、函数等）应该可以扩展，但是不可以修改。

即当需求变化时，你可以通过添加新的代码来扩展这个模块的行为，而不去更改那些已经存在的可以工作的代码。

#### **描述：**
开闭原则主要体现在两个方面：

1.  它们 "面向扩展开放（Open For Extension）"

    意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。
2.  它们 "面向修改封闭（Closed For Modification）"

    模块的源代码是不能被侵犯的，任何人都不允许修改已有源代码。

找出变化的地方：

- 放置挂钩
- 使用回调函数

### 单一职责原则

#### **定义：**

单一职责原则（SRP）的原则体现为：一个对象（方法）只做一件事情。

**何时应该分离职责：**

并不是所有的职责都应该一一分离。

一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。

另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合到一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再分离也不迟。

在实际开发中，因为种种原因违反SRP的情况并不少见，没有必要在任何时候都一成不变地遵守原则。

**优缺点**

优点：降低了单个类或者对象的复杂度，有助于代码复用和单元测试，解耦做得更好。

缺点：增加编写代码的复杂度，增大对象之间相互联系的难度。

**符合原则的设计模式**

代理模式、迭代器模式、单例模式、装饰者模式等

### 最少知识原则

#### **定义：**

最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。

#### **描述：**

最小知识原则指的是设计程序时应当尽量减少对象之间的交互。如果两个对象不必彼此直接通信（？什么情况下会必须直接通信），那这两个对象就不要发生直接的链接，可以找个中介来承担通信作用。

**符合原则的设计模式**

中介者模式(例如vuex的store管理)、外观模式等。

### 思考

在vue里编写组件的时候，与面向对象编程有些类似（？），关注的是组件自身，组件内部封装了一系列相关的数据、逻辑和方法。

在设计组件的时候，组件功能单一是遵循了单一职责原则；组件与其他组件通信时，可能会用到最小知识原则（例如用vuex来传递数据变化）；vue里的插槽设计大约是用了开放封闭原则（？），因为它没有改变原组件，只是在原组件基础上扩展。

## 第二部分 设计模式
### 第四章 单例模式
#### **单例模式的定义：**

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

#### **应用：**

线程池、全局缓存、window对象、登陆浮窗

#### **实现：**

将单例类的原型提出来作为一个普通的原型，引入代理类来帮助该原型实现单例模式。（透明，代码整洁，原型复用度高）

### 第五章 策略模式

**策略模式的定义：**

定义一系列的算法，把它们一个个封装起来，并且使它们可以很方便地相互替换。

**应用：**

针对同一种问题，不同类型数据需要有不同解决方案。例如发奖金这个问题，不同绩效的人会有不同的年终奖计算方式。

**基本思路：**

一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，它接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。p73

即context负责获取参数和选择策略，而具体的运算过程都交给策略来做。

**实现：**

- 所有策略都是单个的function，context使用if-else挑选策略。（缺点：context庞大，需要包含所有逻辑分支，缺乏弹性，一旦策略有变化，例如策略名称，context和策略可能都要修改）

- 策略包在一个对象中，context使用属性名挑选策略。或者说，将要选择的策略直接传入context，由context直接调用。（消灭if-else语句，策略的实现方式与context完全解耦）

**应用：**

表单验证

### 第六章 代理模式

**代理模式的定义：**

为一个对象提供一个代用品或占位符，以便控制对它的访问。

**常见代理：**

代理的原理都是一样的，只不过作用不同而存在类型不同的缓存。例如：

- 保护代理：控制不同权限的对象对目标对象的访问。

- 虚拟代理：将一些开销很大的对象，延迟到真正需要它的时候才去创建。

- 缓存代理：代理里增加缓存，当传入参数一致时，可以返回之前得到的缓存结果。

**应用：**

图片预加载（虚拟代理），合并http请求（虚拟代理），惰性加载（虚拟代理），缓存代理（缓存之前请求过的数据）

**其余常见代理：**

防火墙代理、远程代理、智能引用代理、写时复制代理


### 第七章 迭代器模式

将迭代的过程从业务逻辑中分离出来。现在绝大部分语言都内置了迭代器。

内部迭代器： 只需初始调用，然后接手后续的所有迭代(例如Array.prototype.forEach)。

外部迭代器： 必须显示请求迭代下一个元素（像generator和yield)。

### 第八章 发布—订阅模式

也叫观察者模式。

其优点明显：1.时间上解耦 2.对象之间的解耦

缺点： 消耗一定的时间和内存，当过多使用时，模块与模块之间的联系隐藏到了背后，不易追踪bug

**“推模式”：**
事件发生时，发布者一次性把所有更新的状态和数据都推送给订阅者。

**“拉模式”：**
事件发生时，发布者仅仅通知事件已经发生，由订阅者调用发布者提供的其他接口来获取数据。

### 第九章 命令模式

**应用场景：**

有时候需要向某些对象发送请求，但是并不知道的请求的接收者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

请求者将事件转化为命令，接收者按照命令执行封装好的函数。

命令可以撤销、重做、排队。

文末提到命令模式在js中是一种隐形的模式。通篇读下来，我大概理解了命令模式想说什么，但是还是想不到在js里是个怎样的形式。是因为太普遍了以至于没有意识到吗？

**宏命令:**

一组命令的集合，是命令模式与组合模式的产物。

### 第十章 组合模式

宏命令就是命令模式和组合模式的产物，它生成了一颗命令树，非叶子节点把命令往下传递，直到找到树的叶子节点。叶子节点才是真正要执行的命令。

每当对宏命令进行一次请求时，实际上就是深度遍历了这棵命令树。

**一些值得注意的地方：（p147）**

1. 组合模式不是父子关系，是has-a（聚合）关系。
2. 对叶对象操作的一致性。
3. 双向映射关系：当一个叶子节点在树里重复出现时，并不适合使用组合模式。这种情况下必须建立双向映射关系。

**引用父对象**

在宏命令中，树的结构是从上至下的。但是有时候我们需要子节点保持对父节点的引用。

**应用场景：**

- 表示对象的部分-整体层次结构
- 客户希望统一对待树中的所有对象。

### 第十一章 模板方法（Template Method）

基于继承的设计模式

模板方法封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。

抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，需要子类重写这些方法。如果能确定所有子类都会使用某一个具体方法时，这个具体方法也可以写在抽象类中。

如果子类没有重写抽象方法的话，那么程序就会报错。检查子类有没有重写所有抽象方法的方案有以下两个：

1. 使用鸭子类型来模拟接口检查，确保子类重写了父类的办法。但是这个方案会带来不必要的复杂性，而且需要程序员主动检查这些接口。

2. 在需要被重写的抽象方法中直接抛出异常。如果抽象方法没有被重写，那么子类在调用该方法时就会沿着原型链找到抽象方法并运行，此时就可以获得一个报错。 实现简单，代价小，但是获得错误的时间点太靠后，只能将程序运行起来才知道是否报错。

**钩子方法**

放置钩子是隔离变化的一种常见手段。我们在父类容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要挂钩，这由子类自行决定。

**好莱坞原则**

我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些组件。而底层组件不可以去使用高层组件。

好莱坞原则有多个适用场景，例如模板方法，发布-订阅模式，回调函数等等。


### 第十二章 享元模式（flyweight）

用于性能优化。

**内部状态与外部状态：**

- 内部状态储存于对象内部
- 内部状态可以被一些对象共享
- 内部状态独立于具体的场景，通常不会改变
- 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。
- 内部状态有多少种组合，系统中便最多存在多少个对象。

使用享元模式的关键是如何区别内部状态和外部状态。

**享元模式的通用结构：**

- 对象工厂。只有当某种共享对象被真正需要时，它才从工厂中被创建出来。(有点单例模式的意思)
- 管理器。记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来。

**适用场景：**

- 一个程序中使用了大量的相似对象
- 由于使用了大量对象，造成了很大的内存开销
- 对象的大多数状态都可以变为外部状态
- 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象

**对象池** p175

对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后，再进入池子等待下次被获取。

对象池应用广泛，http连接池和数据库连接池都是其代表应用。在web前端，对象池使用最多的场景大概就是跟DOM有关的操作。如何避免频繁地创建和删除DOM节点就成了一个有意义的话题。

### 第十三章 职责链模式

**定义：**

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。

职责链模式就像是把每部分的处理函数当作节点做成一个单向链表，如果当前节点不能处理则向后传递。

我自己将书上p183的例子用数组储存链表，用Array.prototype.every实现顺序执行。这个无法实现异步职责链。

    var order500 = function(orderType, pay, stock){
      if( orderType === 1 && pay === true){
        console.log("500元，100优惠券")
      }else{
        return true
      }
    }
    var order200 = function(orderType, pay, stock){
      if( orderType === 2 && pay === true){
        console.log("200元，50优惠券")
      }else{
        return true
      }
    }
    var orderNormal = function(orderType, pay, stock){
      if( orderType === 3){
        if( stock > 0){
          console.log("普通购买，无优惠券");
        }else{
          console.log("手机库存不足")
        }
      }
    }

    function chain(arr){
      return (function(orderType, pay, stock){
        arr.every(function(i){
          return i(orderType, pay, stock)
        })
      })
    }
    var order = chain([order500, order200, orderNormal]);
    order(1, true, 500)

**注意点**

当职责链中没有任何一个节点可以处理时，请求就得不到回复。我们可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。

过长的职责链会带来性能损耗？（可是不用职责链也要用if-else分支，都得走一遍，有什么区别呢？）

**AOP实现职责链**

改写Function.prototype.after （3.2.3节）

缺点: 叠加了函数作用域，如果链条太长，那么对性能也会有较大影响。


### 第十四章 中介者模式

中介模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用。所以当一个对象发生改变时，只需要通知中介者对象即可。

中介者模式使各个对象之间得以解耦，以中介者和对象直接的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。

**缺点:**

系统会新增一个中介者对象，因为对象直接交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。


### 第十五章 装饰者模式

在程序开发中，许多时候并不希望某个类天生就非常庞大，一次性包含许多职责，那么我们就可以使用装饰者模式。装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。

传统面向对象语言中的装饰者模式在js中适用的场景并不多，因为我们通常并不太介意改动对象自身。

**使用AOP装饰函数**

Function.prototype.before 和 Function.prototype.after就是典型的例子，在不改动原函数的情况下向原函数添加功能。

用AOP装饰函数的技巧在实际开发中非常有用。不论是业务代码的编写，还是在框架层面，我们都可以把行为依照职责分成粒度更细的函数，随后通过装饰把他们合并到一起，这有助于我们编写一个松耦合和高复用性的系统。

### 第十六章 状态模式

状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。

状态模式把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部。

书上举了一个电灯开关的例子，个人觉得是把电灯的状态都抽离出来做成了一个状态机，给一个状态入口，记录当前状态，剩下的只要在发生变化时切换状态即可。在切换的时候会把该做的都做了。

可以给所有的状态创建一个父类，父类里实现公共方法，比如按下电灯按钮这个方法，但是和模板方法模式一样，需要子类重写具体方法覆盖父类的抽象方法，父类在抽象方法里需要抛出错误来避免子类没有覆盖这个抽象方法。

**状态模式中的优缺点**

优点：

各状态清晰、独立，消灭条件分支语句

缺点：

逻辑分散，状态众多时，需要增加的对象也会很多。

**JS版本的状态机**

p242

### 第十七章 适配器模式

适配器模式的作用是解决两个软件实体间的接口不兼容的问题。


## 参考

- [开放封闭原则（Open Closed Principle）](https://www.cnblogs.com/gaochundong/p/open_closed_principle.html)

