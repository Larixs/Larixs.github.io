---
title: 你不知道的Javascript
tags: [ES]
categories: books
---

# 上卷 (scope & closures & this & object prototypes)

## part1, scope and closures

### scope

1. 参与编译的部分：

- 引擎： 从头到尾负责整个js程序的编译及执行过程。
- 编译器： 负责语法分析及代码生成。
- 作用域： 收集并维护所有声明的标识符（变量），确定当前执行的代码对这些标识符的访问权限。

2. 遇到变量时的简要编译运行过程：

    ``var a = 2;``

    编译器将程序分解并解析成一个抽象语法树（AST），遇到var a时，会先询问作用域是否有一个该名称的变量存在同一个作用域的*集合*中。如果有，则忽略该声明，继续进行编译，否则会要求作用域在当前作用域的*集合*中声明一个新的变量， 并命名为a。

    引擎运行a = 2时，会先询问作用域变量是否存在，如果是，引擎就会使用这个变量，否则继续往上查找。

3. LHS、RHS

   获取变量的值使用的是RHS，为变量赋值（或者说是获得变量的指针？）是用的LHS。 函数声明不会触发LHS。在非严格模式下，LHS在作用域的顶层（即全局作用域）也找不到变量时，全局作用域会创建一个具有该名称的变量并返给引擎。


4. 作用域嵌套

    引擎在当前作用域找不到对应变量时，就会继续向外层作用域查找，直到找到变量或者到达最外层作用域。

    综合示例：

            function test(str){  // 函数传参时有个隐形变量分配，触发LHS。
                var a = str;  // 编译器在test作用域内声明变量a，引擎触发RHS查找str的值，触发LHS为变量a赋值。
                b = a; // 因为没有var这个声明符，所以在编译器没有在test作用域内声明变量b。
                       // 引擎运行时，触发RHS查找a的值，触发LHS查找b。LHS在test作用域内没有找到b，便向外层查找，直到全局作用域。全局作用域也没有变量b，在非严格模式下，全局作用域创建了一个全局变量b，并返回给引擎。
            }

            test('hello world');  // RHS查找函数。
            console.log(b); // b >> 'hello world'

5. 欺骗词法

    欺骗词法是指运行时“修改”（或者说欺骗）词法作用域，典型的有eval和with。

    弊端：

    - 由于作用域的不确定性，影响编译器的优化。
    - 在严格模式下会限制或者禁止欺骗词法。
    - 代码可读性下降。

