---
title: SSR实践
tags: [study notes]
categories: ssr
---

在业务中，为了使用vue+ssr，选用nuxt.js作为基础框架进行开发。

## nuxt或ssr的优势

- 加快首屏渲染速度
- 利于SEO
- nuxt接管了打包的一系列事，方便使用

## 使用nuxt中遇到的问题

- 服务器端渲染的页面，referer指向不对，需要手动透传。
- nuxt项目页面与非nuxt项目页面之间，通过浏览器的前进后退按钮访问时，可能会出现串账号的问题（见以下问题1）。
- 功能特别多的脚手架，在碰见特殊需求时一般都不够灵活。
- nuxt的报错有些微的不友好。

## 1. 思考：客户的登录状态是否应该在服务器端获取？

在服务器端获取客户的登录状态或者账户信息，是因为在服务器端请求接口可以减少等待时间。

目前正在迁移项目，将非ssr的项目迁为ssr项目。因为个人中心页面数量多，因此想采用分批迁移替换的方式。

但迁移中发现一个问题：

` 如果所有可以改变登录状态页面不在一个ssr项目里，通过浏览器的前进后退，可能会串账户信息。 `


复现条件：
- 登录状态通过服务器端发请求提前获取，存在了window.__NUXT__里。
- 如果在服务器端获取了数据，则浏览器端不再重发请求。
- 页面a在项目A里，页面b在项目B里。项目A是ssr。
- a页面可以直接点击跳到b页面。

简单的复现步骤：

在a页面登录账户1，点击跳到b后，b页面正确显示账户1信息。

通过浏览器的回退按钮回到a页面，a页面则显示无账户登录。前进到b页面又有登录状态。

此时就有了ab两个连续访问的页面显示了不同的登录状态。

还有更复杂一点的步骤可以导致a页面显示账户1，b页面显示账户2。这里就不赘述了，但肯定是可以复现的（我是先看见这种情况才发现的bug）。

原因：

b通过浏览器回退回到a时，浏览器直接读取了缓存的a页面的html，该html里携带了登录的信息，且因为有数据，在浏览器端不再发送请求而是直接使用html里的数据，所以a页面在不刷新的情况下一定会为“未登录”。

方案：

    - 临时： asyncData已经获取了数据的情况下，在a页面的created里再次请求接口，保证浏览器无论怎么访问都可以更新数据。（不加loading的情况下可以看见账户信息的突变）
    - 终极： 所有可以触发用户登录状态的页面都放在一个项目里，浏览器前进后退会触发middleware，此时可以更新状态。

