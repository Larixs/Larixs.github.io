---
title: 正则表达式学习笔记
tags: [study notes, reg]
categories: other
---

## 1.对某个字符进行匹配
** 按匹配范围进行分类 **


- 普通字符（如a）：普通字符本身（a）

- 特殊字符（如. 和 \）: \特殊字符 （如 \ . 和 \ \ , -(连字符) 字符不需要被转译）
- 空白字符(非打印字符):

	- \f : 换页符
	- \n : 换行符
- 多个字符中的一个
	- 字符集(如匹配a或者s或者d) : [asd]
	- 字符集合区间(如匹配数字0~9) :

		[0-9]  //完全等同于[0123456789]

		[A-Z]

		[a-z]

		[A-z] //匹配ASCII字符A到z的所有字母,不常用,包含[、^等其他字符
	- 多个字符区间：

		[A-Za-z0-9]
	- 匹配特定类别：

		\d:任何一个数字

		\D:任何一个非（数字）

		\w:字母、数字、下划线

		\W: 非（字母、数字、下划线）

		\s:空白字符

		\S:非空白字符
- 取非匹配: [^0-9] //匹配不上数字的字符
- 匹配除换行符之外的任何单个字符：.
- 或操作符 |。 'x|y'匹配'x'或者'y'。

    例如：

    `/green|red/ //匹配“green apple”中的‘green’和“red apple”中的‘red’`
    `/gree(n|r)ed/ //匹配'greened'或'greered'`

## 2.对字符进行重复匹配

- 匹配一个或多个字符： +

	例子：

	a+  //匹配一个或连续多个a

	\w+ //匹配一个或连续多个字母数字字符

	[0-9]+ //匹配一个或多个数字

- 匹配零个或多个字符： *

	用法和 + 完全一样。

- 匹配零个或一个字符 ： ？
	用法同上。

- 指定重复的次数
	- 精确的值 [0-9]{6}  //重复出现六个数字
	- 闭合区间 \d{2,4} //数字最多重复4次，最少重复两次
	- 半开半闭区间 \d{3,} //至少重复3次

- 懒惰型元字符

	这是个非常有意思的概念。*，+都是尽可能多的匹配，但是存在一种情况是需要尽可能少的匹配，因此引入懒惰型元字符的概念。懒惰型元字符就是匹配尽可能少的字符。

贪婪型元字符 | 懒惰型元字符
-----------|-----------
* | *?
+ | +?
{n,}|{n,}?

## 3. 位置匹配

- 单词 边界： \b   //用于匹配一个单词的开始或者结尾

	\bcat\b  //只匹配cat单词

	\bcat //匹配以cat开头的单词

	cat\b  //匹配以cat结尾的单词

- 非单词 边界： \B //匹配前或后不是单词边界的符号

	\B-\B  //匹配color - coded ，不匹配 nine-digit

- 字符串边界： ^ （字符串开头） $ （字符串结尾）

- 分行匹配模式： (?m) //将行分隔符当做字符串分隔符对待，因此^ $还会匹配行分隔符


## 4.子表达式

### 捕获括号
把一个子表达式当做一个独立的元素使用。子表达式需用（）(称为捕获括号)括起来。

例子：

`(\d{1,3}\.){3}\d{1,3}  // 子表达式\d{1,3}\.重复三次，可以匹配ip地址如10.125.19.211`

`(19|20)\d{2} // 匹配19或者20开始的四位数`

### 非捕获括号 (?:x)

匹配'x'但是不记住匹配项。

    const reg1 = /(?:foo)/;
    const reg2 = /(foo)/;
    const str = 'foo';
    str.replace(reg1, '$1') // '$1' 捕获但是没有记住，所以$1没有值
    str.replace(reg2, '$1') // 'foo' 捕获并且记住，所以$1有值

## 5.回溯引用

回溯引用多用来替换字符串。~~不知道这在js里怎么写。~~

看了书之后，发现回溯引用就是将子表达式化作变量，按照出现顺序通过 \1 \2 ... 进行调用，同一子表达式匹配出的字符串应该是一样的，比如子表达式1匹配到了sat,则后续\1处的调用也必须匹配sat。

例子：

`/(foo) (bar) \1 \2/  // 这个正则表达式能匹配上"foo bar foo bar"，用两个括号分别记住前两个单词，再用\1 \2表示匹配和捕获1(在此是'foo')、捕获2(在此是'bar')一样的字符串。 \1 \2用于正则表达式的匹配环节，$1 $2用于正则表达式的替换环节。`

## 6.断言(条件匹配)

### 先行断言 x(?=y)

匹配'x'，仅当'x'后面跟着'y'。这叫先行断言。

例子：

`/Jack(?=Sprat|Frost)/  // 匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。`

### 后行断言 (?<=y)x

匹配'x'，仅当'x'前面是'y'。这叫后行断言。

`/(?<=Jack|Tom)Sprat/  // 匹配‘ Sprat ’仅仅当它前面是'Jack'或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。`

### 反向(?)先行断言 x(?!y)

匹配'x',仅当'x'后面不是'y'

### 反向(?)后行断言 (?<!y)x

匹配'x',仅当'x'前面不是'y'


### 7. 正则表达式小书上还有些东西，没用过也没看过

等真正需要的时候再学吧，不然又忘了

## 参考链接：

1. [正则表达式-javascript|mdn](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)
